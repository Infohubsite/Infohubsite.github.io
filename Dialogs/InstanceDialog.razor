@using Frontend.Models.DTOs
@using Frontend.Models.Enums
@using System.Text.Json
@inject IEntityDefinitionService EDS
@inject IEntityInstanceService EIS
@inject INotificationService NS

<MudDialog>
    <DialogContent>
        @if (EntityDefinition == null)
        {
            <MudProgressCircular Indeterminate="true" />
        }
        else
        {
            @if (error != null)
            {
                <MudAlert Severity="Severity.Error" Class="my-2">@error</MudAlert>
            }

            <MudForm @ref="form" @bind-IsValid="valid" Class="mt-4">
                @foreach (var field in EntityDefinition.Fields)
                {
                    @switch (field.DataType)
                    {
                        case DataType.Text:
                            <MudTextField T="string"
                                          Label="@field.Name"
                                          Required="field.IsRequired"
                                          RequiredError="@($"{field.Name} is required.")"
                                          ValueChanged="@((string val) => OnValueChanged(field.Name, val))" />
                            break;
                        case DataType.Number:
                            <MudNumericField T="double?"
                                             Label="@field.Name"
                                             Required="field.IsRequired"
                                             RequiredError="@($"{field.Name} is required.")"
                                             ValueChanged="@((double? val) => OnValueChanged(field.Name, val))" />
                            break;
                        case DataType.Date:
                            <MudDatePicker Label="@field.Name"
                                           Required="field.IsRequired"
                                           RequiredError="@($"{field.Name} is required.")"
                                           DateChanged="@((DateTime? val) => OnValueChanged(field.Name, val))"
                                           Clearable="!field.IsRequired" />
                            break;
                        case DataType.Boolean:
                            @if (field.IsRequired)
                            {
                                <MudSwitch T="bool"
                                           Label="@field.Name"
                                           Color="Color.Primary"
                                           Checked="@GetBoolValue(field.Name)"
                                           CheckedChanged="@((bool val) => OnValueChanged(field.Name, val))" />
                            }
                            else
                            {
                                <MudSelect T="bool?" Label="@field.Name" ValueChanged="@((bool? val) => OnValueChanged(field.Name, val))">
                                    <MudSelectItem Value="(bool?)null">Not set</MudSelectItem>
                                    <MudSelectItem Value="(bool?)true">True</MudSelectItem>
                                    <MudSelectItem Value="(bool?)false">False</MudSelectItem>
                                </MudSelect>
                            }
                            break;
                        case DataType.EntityReference:
                            <MudAutocomplete T="Guid?"
                                             Label="@field.Name"
                                             Required="field.IsRequired"
                                             RequiredError="@($"{field.Name} is required.")"
                                             SearchFunc="@((searchTerm, token) => SearchInstances(field.ReferenceTargetEntityDefinitionId, searchTerm))"
                                             ValueChanged="@((Guid? val) => OnValueChanged(field.Name, val))"
                                             ToStringFunc="@(id => GetInstanceNameById(field.ReferenceTargetEntityDefinitionId, id))"
                                             Clearable="!field.IsRequired" />
                            break;
                    }
                }
            </MudForm>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton OnClick="Submit" Color="Color.Primary" Variant="Variant.Filled" Disabled="@(!valid)">@ButtonText</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] private IMudDialogInstance MudDialog { get; set; } = default!;

    [Parameter] public Guid EntityDefinitionId { get; set; }
    [Parameter] public Guid? CurrentInstance { get; set; }
    [Parameter] public string ButtonText { get; set; } = string.Empty;

    private EntityDefinitionDto? EntityDefinition;
    private MudForm form = default!;
    private CreateInstanceDto model = new();
    private string? error;
    private bool valid;

    private readonly Dictionary<Guid, List<EntityInstanceDto>> _instanceCache = new();

    protected override async Task OnInitializedAsync()
    {
        EntityDefinition = await EDS.GetEntityDefinitionAsync(EntityDefinitionId);
        if (EntityDefinition == null)
        {
            error = "Could not load the entity definition. Cannot create instance.";
        }
        else
        {
            foreach (var field in EntityDefinition.Fields)
            {
                if (field.IsRequired)
                {
                    model.Data[field.Name] = field.DataType switch
                    {
                        DataType.Boolean => false,
                        DataType.Number => (double?)null,
                        DataType.Date => (DateTime?)null,
                        DataType.EntityReference => (Guid?)null,
                        _ => string.Empty,
                    };
                }
            }
        }
    }

    private async Task<IEnumerable<Guid?>> SearchInstances(Guid? targetDefId, string searchTerm)
    {
        if (targetDefId == null)
            return Enumerable.Empty<Guid?>();

        // Step 1: Populate our local cache for this entity type if it's not already populated.
        if (!_instanceCache.ContainsKey(targetDefId.Value))
        {
            var instances = await EIS.GetInstancesAsync(targetDefId.Value);
            _instanceCache[targetDefId.Value] = instances ?? new List<EntityInstanceDto>();
        }

        var cachedInstances = _instanceCache[targetDefId.Value];

        // Step 2: Perform the search on the now-cached data.
        if (string.IsNullOrWhiteSpace(searchTerm))
            return cachedInstances.Select(i => (Guid?)i.Id);

        return cachedInstances
            .Where(i => GetInstanceDisplayName(i).Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
            .Select(i => (Guid?)i.Id);
    }

    // This function is now SYNCHRONOUS and uses the local _instanceCache.
    private string GetInstanceNameById(Guid? entityDefId, Guid? instanceId)
    {
        if (instanceId == null || entityDefId == null)
            return "";

        // Read directly from the local component cache.
        if (!_instanceCache.TryGetValue(entityDefId.Value, out var instances))
        {
            // This can happen if a value is pre-selected before a search is done.
            // Returning the ID is a safe fallback.
            return instanceId.Value.ToString();
        }

        var instance = instances.FirstOrDefault(i => i.Id == instanceId.Value);

        return instance != null ? GetInstanceDisplayName(instance) : instanceId.Value.ToString();
    }

    private string GetInstanceDisplayName(EntityInstanceDto instance)
    {
        if (instance?.Data == null) return instance?.Id.ToString() ?? "";

        var nameKey = instance.Data.Keys.FirstOrDefault(k => k.Contains("Name", StringComparison.OrdinalIgnoreCase)) ?? instance.Data.Keys.FirstOrDefault();

        if (nameKey != null && instance.Data.TryGetValue(nameKey, out var value) && value is JsonElement json)
            return json.ToString();

        return instance.Id.ToString();
    }

    private bool GetBoolValue(string fieldName)
    {
        if (model.Data.TryGetValue(fieldName, out object? value) && value is bool boolValue)
            return boolValue;
        return false;
    }

    private void OnValueChanged(string fieldName, object? value)
    {
        // Check if the value is null or an empty string for text fields
        bool isNullOrEmpty = value == null || (value is string s && string.IsNullOrEmpty(s));

        if (isNullOrEmpty)
        {
            // If the value is cleared, remove the key from the dictionary
            model.Data.Remove(fieldName);
        }
        else
        {
            // Otherwise, add or update the value
            model.Data[fieldName] = value;
        }
    }

    private async Task Submit()
    {
        await form.Validate();
        if (!valid) return;

        foreach (string? key in model.Data.Where(kvp => kvp.Value == null).Select(kvp => kvp.Key).ToList())
            model.Data.Remove(key);

        var (instance, response) = await EIS.CreateInstanceAsync(EntityDefinitionId, model);

        if (instance != null)
            MudDialog.Close(DialogResult.Ok(instance));

        if (response == null)
            error = $"Failed to create instance. Did not receive a response from the server";
        else if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
            error = $"Failed to create insatnce. {(await response.Content.ReadFromJsonAsync<Rsp>())?.message}";
        else
            error = $"Failed to create instance. The server responded with status: {response.StatusCode}.";
    }

    private void Cancel() => MudDialog.Cancel();

    private class Rsp
    {
        public string message { get; set; } = string.Empty;
    }
}